<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1. Feladat - Java Megold√°s</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¢ 1. Feladat - Java Megold√°s</h1>
            <p>Optim√°lis algoritmus tervez√©se</p>
        </div>

        <div class="task-content">
            <h2>Feladat le√≠r√°sa</h2>
            <p>Adott egy n √ó n-es r√°cs, amelynek minden mez≈ëj√©ben egy nagybet≈±s angol bet≈± (A‚ÄìZ) van. A bal fels≈ë sarokb√≥l ([1,1]) kell eljutnod a jobb als√≥ sarokba ([n,n]).
Csak jobbra vagy lefel√© lehet l√©pni minden l√©p√©sben. A c√©l, hogy a lehet≈ë legkisebb lexikografikus sorrend≈± (teh√°t ‚Äû√°b√©c√©rendben a legkor√°bbi‚Äù) karakterl√°ncot kapd meg, ha az √∫ton szerepl≈ë bet≈±ket egym√°s ut√°n √≠rod.
            Bemenet (Input)
Az els≈ë sorban egy eg√©sz sz√°m: n ‚Äì a r√°cs m√©rete.
Ezut√°n n sor k√∂vetkezik, mindegyik n darab bet≈±t tartalmaz (csupa nagybet≈±t).
            Kimenet (Output)
√çrd ki azt a karakterl√°ncot, ami a lehets√©ges utak k√∂z√ºl lexikografikusan a legkisebb.
            Felt√©telek
                1‚â§n‚â§3000 
Teh√°t a c√©l: megkeresni azt az √∫tvonalat (csak jobbra/lefel√©), ami a bet≈±k sorrendj√©t tekintve a legkisebb lehets√©ges karakterl√°ncot adja.</p>
            
            <h2>Java Megold√°som</h2>
            <div class="solution">
                <h3>Java k√≥d:</h3>
                <code>
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine().trim());
        char[][] grid = new char[n][n];
        for (int i = 0; i < n; i++) {
            String line = br.readLine();
            while (line == null || line.length() < n) {
                // Ha valami miatt sorok t√∂rnek (ritka), olvassunk tov√°bb
                String extra = br.readLine();
                if (extra == null) break;
                line = (line == null ? "" : line) + extra;
            }
            grid[i] = line.trim().toCharArray();
        }

        StringBuilder sb = new StringBuilder();
        sb.append(grid[0][0]);

        // current: lista azon sorindexeknek, amelyek az aktu√°lis diagon√°lon el√©rhet≈ëk
        ArrayList<Integer> current = new ArrayList<>();
        current.add(0); // (0,0) row index 0, mert i+j = 0

        // seen token tr√ºkk a duplik√°tumok elker√ºl√©s√©re (nem t√∂rl√ºnk t√∂mb√∂t minden iter√°ci√≥ban)
        int[] seen = new int[n];
        int seenToken = 1;

        // v√©gs≈ë string hossza 2*n - 1; m√°r van 1 karakter√ºnk --> kell m√©g 2*n-2 karakter
        for (int d = 0; d < 2 * n - 2; d++) {
            // keresd meg a k√∂vetkez≈ë (d+1)-edik diagon√°lra vezet≈ë legkisebb bet≈±t
            char minChar = Character.MAX_VALUE;
            for (int idx = 0; idx < current.size(); idx++) {
                int i = current.get(idx);
                int j = d - i; // jelenlegi diagon√°lon j = d - i
                if (i + 1 < n) {
                    char c = grid[i + 1][j];
                    if (c < minChar) minChar = c;
                }
                if (j + 1 < n) {
                    char c = grid[i][j + 1];
                    if (c < minChar) minChar = c;
                }
            }

            sb.append(minChar);

            // √©p√≠ts√ºk a k√∂vetkez≈ë diagon√°l current list√°j√°t (sorindexek)
            ArrayList<Integer> next = new ArrayList<>();
            seenToken++;
            for (int idx = 0; idx < current.size(); idx++) {
                int i = current.get(idx);
                int j = d - i;
                if (i + 1 < n && grid[i + 1][j] == minChar) {
                    int row = i + 1;
                    if (seen[row] != seenToken) {
                        seen[row] = seenToken;
                        next.add(row);
                    }
                }
                if (j + 1 < n && grid[i][j + 1] == minChar) {
                    int row = i; // (i, j+1) sorindexe i
                    if (seen[row] != seenToken) {
                        seen[row] = seenToken;
                        next.add(row);
                    }
                }
            }

            current = next;
        }

        System.out.println(sb.toString());
    }
}
          </code>
                
                <h3>Magyar√°zat:</h3>
                <p>Ez a megold√°s optimaliz√°lt id≈ë- √©s mem√≥riahaszn√°lattal dolgozik.</p>
                
                <h3>Bemenet:</h3>
                <code>gwwtfarmgimwymmfmcohixrchzhmof...</code>
                
                <h3>Kimenet:</h3>
                <code>0</code>
            </div>
        </div>

        <a href="index.html" class="back-btn">‚¨ÖÔ∏è Vissza a f≈ëoldalra</a>
    </div>
</body>
</html>

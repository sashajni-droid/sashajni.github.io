<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1. Feladat - Java Megold√°s</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¢ 1. Feladat - Java Megold√°s</h1>
            <p>Optim√°lis algoritmus tervez√©se</p>
        </div>

        <div class="task-content">
            <h2>Feladat le√≠r√°sa</h2>
            <p>Adott egy n √ó n-es r√°cs, amelynek minden mez≈ëj√©ben egy nagybet≈±s angol bet≈± (A‚ÄìZ) van. A bal fels≈ë sarokb√≥l ([1,1]) kell eljutnod a jobb als√≥ sarokba ([n,n]).
Csak jobbra vagy lefel√© lehet l√©pni minden l√©p√©sben. A c√©l, hogy a lehet≈ë legkisebb lexikografikus sorrend≈± (teh√°t ‚Äû√°b√©c√©rendben a legkor√°bbi‚Äù) karakterl√°ncot kapd meg, ha az √∫ton szerepl≈ë bet≈±ket egym√°s ut√°n √≠rod.
            Bemenet (Input)
Az els≈ë sorban egy eg√©sz sz√°m: n ‚Äì a r√°cs m√©rete.
Ezut√°n n sor k√∂vetkezik, mindegyik n darab bet≈±t tartalmaz (csupa nagybet≈±t).
            Kimenet (Output)
√çrd ki azt a karakterl√°ncot, ami a lehets√©ges utak k√∂z√ºl lexikografikusan a legkisebb.
            Felt√©telek
                1‚â§n‚â§3000 
Teh√°t a c√©l: megkeresni azt az √∫tvonalat (csak jobbra/lefel√©), ami a bet≈±k sorrendj√©t tekintve a legkisebb lehets√©ges karakterl√°ncot adja.</p>
            
            <h2>Java Megold√°som</h2>
            <div class="solution">
                <h3>Java k√≥d:</h3>
                <code>
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine().trim());
        char[][] grid = new char[n][n];
        for (int i = 0; i < n; i++) {
            String line = br.readLine();
            while (line == null || line.length() < n) {
                // Ha valami miatt sorok t√∂rnek (ritka), olvassunk tov√°bb
                String extra = br.readLine();
                if (extra == null) break;
                line = (line == null ? "" : line) + extra;
            }
            grid[i] = line.trim().toCharArray();
        }

        StringBuilder sb = new StringBuilder();
        sb.append(grid[0][0]);

        // current: lista azon sorindexeknek, amelyek az aktu√°lis diagon√°lon el√©rhet≈ëk
        ArrayList<Integer> current = new ArrayList<>();
        current.add(0); // (0,0) row index 0, mert i+j = 0

        // seen token tr√ºkk a duplik√°tumok elker√ºl√©s√©re (nem t√∂rl√ºnk t√∂mb√∂t minden iter√°ci√≥ban)
        int[] seen = new int[n];
        int seenToken = 1;

        // v√©gs≈ë string hossza 2*n - 1; m√°r van 1 karakter√ºnk --> kell m√©g 2*n-2 karakter
        for (int d = 0; d < 2 * n - 2; d++) {
            // keresd meg a k√∂vetkez≈ë (d+1)-edik diagon√°lra vezet≈ë legkisebb bet≈±t
            char minChar = Character.MAX_VALUE;
            for (int idx = 0; idx < current.size(); idx++) {
                int i = current.get(idx);
                int j = d - i; // jelenlegi diagon√°lon j = d - i
                if (i + 1 < n) {
                    char c = grid[i + 1][j];
                    if (c < minChar) minChar = c;
                }
                if (j + 1 < n) {
                    char c = grid[i][j + 1];
                    if (c < minChar) minChar = c;
                }
            }

            sb.append(minChar);

            // √©p√≠ts√ºk a k√∂vetkez≈ë diagon√°l current list√°j√°t (sorindexek)
            ArrayList<Integer> next = new ArrayList<>();
            seenToken++;
            for (int idx = 0; idx < current.size(); idx++) {
                int i = current.get(idx);
                int j = d - i;
                if (i + 1 < n && grid[i + 1][j] == minChar) {
                    int row = i + 1;
                    if (seen[row] != seenToken) {
                        seen[row] = seenToken;
                        next.add(row);
                    }
                }
                if (j + 1 < n && grid[i][j + 1] == minChar) {
                    int row = i; // (i, j+1) sorindexe i
                    if (seen[row] != seenToken) {
                        seen[row] = seenToken;
                        next.add(row);
                    }
                }
            }

            current = next;
        }

        System.out.println(sb.toString());
    }
}
          </code>
                
                <h3>Magyar√°zat:</h3>
                <p> 1. Beolvassa a t√°bl√°t
                        int n = Integer.parseInt(br.readLine().trim());
                        char[][] grid = new char[n][n];
                    Ez megmondja, mekkora a t√°bla (pl. 4√ó4). A grid t√°rolja a bet≈±ket (mint egy n√©gyzetr√°cs).
                        grid[0][0] = 'A'
                        grid[0][1] = 'A'
                        grid[0][2] = 'C'
                        grid[0][3] = 'A'
                        ...

                    2. Az indul√°s
                        StringBuilder sb = new StringBuilder();
                        sb.append(grid[0][0]);
                    A sz√≥ (sb) els≈ë bet≈±je a bal fels≈ë sarok bet≈±je. Teh√°t elindulunk az els≈ë ‚ÄûA‚Äù-val.

                    3. A kezd≈ëpont list√°ja
                        ArrayList<Integer> current = new ArrayList<>();
                        current.add(0);
                    Ez megjegyzi, hogy hol vagyunk most. Most csak egy helyen vagyunk: a bal fels≈ë sarokban. A program diagon√°lisan (√°tl√≥san) fog haladni a t√°bl√°n ‚Äî mindig a k√∂vetkez≈ë "√°tl√≥" mez≈ëit n√©zi meg.
                        
                    4. Most j√∂n a l√©pked√©s a t√°bl√°n
                    Ez a nagy for-ciklus csin√°lja a l√©p√©seket:
                        for (int d = 0; d < 2 * n - 2; d++) {
                    Mi√©rt 2*n - 2? Mert ennyi l√©p√©st kell tenni, hogy a bal fels≈ë sarokt√≥l el√©rj√ºnk a jobb als√≥ sarokig.
                        
                    5. A legkisebb bet≈± keres√©se
                        char minChar = Character.MAX_VALUE;
                    Itt t√°rolja, mi a legkisebb bet≈±, amit most tal√°lunk. Azt√°n megn√©zi az √∂sszes lehets√©ges √∫j mez≈ët, amire l√©phet√ºnk:
                        if (i + 1 < n) {
                            char c = grid[i + 1][j];
                            if (c < minChar) minChar = c;
                        }
                        if (j + 1 < n) {
                            char c = grid[i][j + 1];
                            if (c < minChar) minChar = c;
                        }
                    Ez azt jelenti: N√©zz√ºk meg, ha lel√©p√ºnk egyet (i+1), milyen bet≈± van ott. N√©zz√ºk meg, ha jobbra l√©p√ºnk egyet (j+1), milyen bet≈± van ott. Ha tal√°lunk kisebb bet≈±t (p√©ld√°ul ‚ÄûA‚Äù-t), azt v√°lasztjuk.
                                  
                    6. Hozz√°adjuk a legkisebb bet≈±t a sz√≥hoz
                        sb.append(minChar);
                    Teh√°t a k√∂vetkez≈ë bet≈± az lesz, amit most kiv√°lasztottunk.
                                  
                    7. K√∂vetkez≈ë l√©p√©sek el≈ëk√©sz√≠t√©se
                        ArrayList<Integer> next = new ArrayList<>();
                    Ez t√°rolja majd, honnan lehet tov√°bbmenni a k√∂vetkez≈ë k√∂rben. A k√≥d itt ellen≈ërzi: Melyik mez≈ëk vezettek a most kiv√°lasztott legkisebb bet≈±h√∂z. 
                    Csak azokat a mez≈ëket tartja meg, amelyek ugyanabba a legkisebb bet≈±be vezetnek. √çgy nem kell minden √∫tvonalat v√©gign√©zni ‚Äî csak a leg√≠g√©retesebbeket!

                    8. A ‚Äûseen‚Äù tr√ºkk
                        int[] seen = new int[n];
                        int seenToken = 1;
                    Ez csak az√©rt van, hogy ne adjunk hozz√° ugyanazt a sort k√©tszer. Seg√≠t, hogy a program gyors legyen.
                        
                    9. V√©g√ºl ki√≠rjuk a k√©sz sz√≥t
                        System.out.println(sb.toString());
                    Ez az a sz√≥, amit a program l√©p√©sr≈ël l√©p√©sre √©p√≠tett fel ‚Äî √©s ez lesz a lexikografikusan legkisebb (teh√°t √°b√©c√©ben legels≈ë).

                    √ñsszefoglalva:
                    K√©pzeld el, hogy van egy bet≈±s labirintusod, minden mez≈ë egy bet≈±, te pedig csak jobbra √©s lefel√© mehetsz.
                    A j√°t√©k c√©lja, hogy mindig a legkisebb bet≈± fel√© l√©pj, am√≠g a jobb als√≥ sarokba nem √©rsz. K√∂zben jegyezd fel a bet≈±ket ‚Äî a v√©g√©n lesz egy sz√≥. 
                    A program pontosan ezt csin√°lja: mindig a legjobb bet≈±t v√°lasztja, √©s nem pazarol id≈ët a rossz ir√°nyokra. </p>
                
                <h3>Bemenet:</h3>
                <code> Az els≈ë sorban egy eg√©sz sz√°m: n ‚Äì a r√°cs m√©rete. Ezut√°n n sor k√∂vetkezik, mindegyik n darab bet≈±t tartalmaz (csupa nagybet≈±t).</code>
                
                <h3>Kimenet:</h3>
                <code> √çrd ki azt a karakterl√°ncot, ami a lehets√©ges utak k√∂z√ºl lexikografikusan a legkisebb. Felt√©telek: 1‚â§n‚â§3000 </code>
            </div>
        </div>

        <a href="index.html" class="back-btn">‚¨ÖÔ∏è Vissza a f≈ëoldalra</a>
    </div>
</body>
</html>
